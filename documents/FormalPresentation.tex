\documentclass[12pt]{article}

%opening
\title{ChangeEngine Game Engine}
\author{By Cedric Wienold,\\
California Polytechnic Unversity,\\
San Luis Obispo, CA\\\\
Advised by Dr. Michael Haungs\\\\}
\date{\today}

\usepackage{enumerate}
\usepackage{amsmath}

\begin{document}
  
  \maketitle

  \thispagestyle{empty}

  \vfill

  \begin{flushright}
    
    Date Submitted:\makebox[1.5in]{\hrulefill}

    \vspace{12pt}
    
    Advisor:\makebox[1.5in]{\hrulefill}
  \end{flushright}

  \newpage
  
  \pagenumbering{roman}

  \tableofcontents

  \newpage

  \addcontentsline{toc}{section}{Abstract}
  \begin{abstract}
    We propose to design a game engine which will provide the framework for fast, simple deployment of games. We analyzed several different game engine designs to allow programmers to work on game design rather than programming the structure of windows, graphics, sounds, et cetera, but allow them to program a wide range of 2D games. The programmer will handle the logic of each interaction on his own, but trivial functions such as drawing, collision detection, and input will be handled by this engine. The engine is available as a static library programmed in C++, which gives the user the power to program in any language that can implement such a library. A major feature of this engine is pluggable functions which can be implemented by the user, such as artificial intelligence.
  \end{abstract}
  
  \newpage
  
  \pagenumbering{arabic}

  \section{Introduction}
    Game engines can be difficult to learn for a programmer who has just downloaded the libraries or source code for it. The main issues we see are that the programmer is expected to do a lot of work to get started: rudimentary operations like window creation and input detection can be hard to wrap one's mind around. Our goal is to look from a novice's point of view, with an engine which will hand-hold them through these operations until they feel able to extend my own engine's classes. We have no delusions of grandeur: If a programmer sufficiently experienced in game programming sees a need that we do not fulfill, he is free to overload it with his own code.

    We also feel that the basic logic of the program is the responsibility of whoever is programming the game. Our engine provides functions which are necessary to most games, namely collision detection, but the implementer of the engine is responsible for what happens between the objects our engine provides.

  \section{Game Engine}
    The game engine supports two main ways of implementing its classes: managed and unmanaged.
\subsection{Managed Engine}
The managed engine provides memory management benefits and ease of use at the cost of flexibility to the user. Everything the programmer creates or instantiates will be done through the overarching game engine class.

\subsubsection{Usage}
\begin{enumerate}
 \item \begin{verbatim} ChangeEngine* engine = ChangeEngine::Initiate(); \end{verbatim}
This is the overarching game engine class, through which most of our operations will take place.
 \item \begin{verbatim} engine->setWindowCaption("Test Window"); \end{verbatim}
The programmer may wish to use a custom window title, as this is a windowed application. Full screen is not yet supported.
 \item \begin{verbatim} engine->createWindow(screen_width,screen_height,bpp); \end{verbatim}
This sets up the game window with the given width, height, and color depth.
 \item \begin{verbatim} engine->createLevel("Level1"); \end{verbatim}
Scenes in this engine are split into ``Levels'', each of which contains several GameObject classes.
 \item \begin{verbatim} engine->createGameObject("Level1","Object1"); \end{verbatim}
This creates ``Object1'' and places it into ``Level1'' to be handled there.
 \item \begin{verbatim} engine->attachImageToGameObject("Level1","Object1",
"filename.png",tilewidth,tileheight); \end{verbatim}
This will attach an image to ``Object1'', also known as an 'avatar'. This is not a default operation for GameObjects, as it is likely the user will want to have an object with no image (for logical operations and such). ``tilewidth'' and ``tileheight'' are terms used in the context of tile sets, where multiple sprites of animation are contained in the same file. Sprite width and height are considered to be the same for all sprites in a tile set.
 \item \begin{verbatim} engine->addAvatarState("Level1","Object1",spritecount); \end{verbatim}
This creates a state for the avatar and sets the number of sprites in that state. In the actual image file, each state is on a single row of tiles, and the sprite count is the number of sprites available on that row of animation. In this way, the tile set can have a variable number of frames of animation for each state.

A state can be something as simple as the direction the object is facing, or an action it is taking, or both. The programmer must make sure to keep track of the order states are given, as they added from the top of the file down, and are indexed by integer starting from zero.
 \item \begin{verbatim} engine->drawObject("Level1","Object1",state,frame); \end{verbatim}
This will draw ``Object1'' of ``Level1'' to the window with the given state and frame, as given above. Going outside the bounds of the number of states added, or the number of frames in that state, will result in undefined operation.
 \item ... Game Operations ...
 \item \begin{verbatim} ChangeEngine::Destroy(); \end{verbatim}
This will make use of the game engine's internal memory management framework to remove all objects created so that the programmer need not worry about it.
\end{enumerate}

\subsection{Unmanaged Engine}
The game engine provides the programmer with unrestricted access to each class contained therein. While the programmer must do his own memory management to prevent leaks, he is not restricted to our ``Level'' framework or even our own drawing functions. What follows is only an example of what can be done with the freedom of an unmanaged engine.

\begin{enumerate}
 \item \begin{verbatim} ChangeEngine* engine = ChangeEngine::Initiate(); \end{verbatim}
 \item \begin{verbatim} engine->setWindowCaption("Test Window"); \end{verbatim}
 \item \begin{verbatim} engine->createWindow(screen_width,screen_height,bpp); \end{verbatim}
 \item \begin{verbatim} GameObject* object = new GameObject(); \end{verbatim}
 \item \begin{verbatim} object->setWidth(tilewidth); \end{verbatim}
 \item \begin{verbatim} object->setHeight(tileheight); \end{verbatim}
 \item ... Game Operations ...
 \item \begin{verbatim} object->drawImage(engine->getWindow(),state,frame); \end{verbatim}
 \item \begin{verbatim} SDL_Flip(engine->getWindow()->getScreen()); \end{verbatim}
 \item ... Game Loop until Finished ...
 \item \begin{verbatim} GameObject::Destroy(object); \end{verbatim}
 \item \begin{verbatim} engine->Destroy(); \end{verbatim}
\end{enumerate}

We have made every attempt to expose useful variables in each object. One need only browse the available header files to understand each function. For example, ChangeEngine's GameWindow class contains an SDL\_Surface called ``screen'', which we make available for use in SDL operations with \begin{verbatim}getScreen()\end{verbatim}.

Take note that the GameObject class also has its own static destruction function. In an unmanaged engine, it will be the programmer's responsibility to locate all applicable class destruction functions and use them.

  \section{Design and Implementation}
    ChangeEngine will fulfill the following software requirements:

\begin{enumerate}
  \item General Requirements

  \begin{enumerate}
    \item Single library implementing all functions for a rudimentary game

    \begin{enumerate}
      \item Engine Class
      \item Level Container
      \item Game Object Container
      \item Input Listener
      \item Collision Listener
    \end{enumerate}

    \item Extensible classes for programmers to ``plug in'' their own logic

    \begin{enumerate}
      \item Artificial Intelligence
      \item Input Handler
      \item Collision Handler
    \end{enumerate}

  \end{enumerate}

  \begin{enumerate}
    \item SDL Usage
    \item Collision Detection
    \item Artificial Intelligence
  \end{enumerate}

\end{enumerate}



  \section{Tools and Teamwork}
    This project will primarily be programmed by Cedric Wienold using various programming environments supporting C++ code. Teamwork will be limited to interviews with industry professionals concerning algorithms and class organization advice.

  \section{Analysis}
    Research will be conducted on the following areas, and methods and results will be included in the appenix.

  \section{Related Work}

  \section{Conclusions}

  \section{Future Improvements}
    This project will remain open source for any programmer to extend and improve upon it. ChangeEngine will maintain a pluggable interface in many ways so that programmers need only design their own functions and pass them into the engine if they wish to use them. Artificial intelligence, collision detection, and input detection are all areas which programmers can design their own plug-ins for.

As far as future improvements to the game engine go, the following is a noncomprehensive list:

\begin{enumerate}
 \item Change object references from strings to integers, to make loop-based instantiation easier.
 \item Use several debug modes to change terminal output.
 \item Continue building more specific error codes for all classes.
 \item Create single ``draw'' function for a level which will draw all managed objects.
 \item Handle timers or threads in ChangeEngine so the user need not be concerned with it.
\end{enumerate}


  \newpage

  \appendix
  \section{Research}

  \subsection{Collision Detection}
    In an interview with Cal Poly Alumni Computer Science alumni Daniel Nutting, methods of collision detection employing best possible complexity in average cases were outlined, with worst possible complexity in edge cases being sacraficed. This method will be called the ``Grid Collision Detection'' method.

    \subsubsection{Grid Collision Detection}
      \emph{Theory: } Truly basic collision detection entails each object checking against all other objects for collision, and doing the same for every object. This leads to an average $O(n^2)$.

      The most apparent problem is repeated checks. One solution can be a stack method. For each object, push onto stack. Check collision with everything behind it. INCLUDE PSEUDOCODE HERE.

      The next issue is restricting the number of objects to check on. If objects are not close to each other, there is no point in checking. This is where the grid comes in. For a set of objects, calculate the average X and Y coordinates, and split the field there into 4 quadrants. Do this more as is necessary for the number of objects. INCLUDE PSEUDOCODE HERE.

  \section{Source Code}
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla ac felis nibh. Maecenas vel risus erat, non convallis risus. Vivamus congue suscipit porta. Fusce cursus lobortis metus et rhoncus. Nulla in ligula eget felis vestibulum iaculis. Nullam ac enim at lorem iaculis accumsan. Nullam at diam a turpis blandit tincidunt ut vitae ipsum. Integer quis enim eget est porta rhoncus. Vivamus commodo, lacus nec laoreet pretium, nunc lectus tincidunt mauris, blandit lobortis erat ligula pretium quam. Mauris et libero nec felis tempor aliquam. Maecenas lacus ante, fringilla eget convallis et, fringilla a dui. Nam bibendum, elit porttitor blandit imperdiet, est magna fringilla diam, eu accumsan ante nisl at metus. Cras non gravida quam. Nulla nec lorem lorem. Proin et massa mauris. Aenean non metus orci. Maecenas porta purus et ligula consequat tempus.

\end{document}
