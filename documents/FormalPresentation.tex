\documentclass[12pt]{article}

%opening
\title{ChangeEngine Game Engine}
\author{By Cedric Wienold,\\
California Polytechnic Unversity,\\
San Luis Obispo, CA\\\\
Advised by Dr. Michael Haungs\\\\}
\date{\today}

\usepackage{enumerate}
\usepackage{amsmath}

\begin{document}
  
  \maketitle

  \thispagestyle{empty}

  \vfill

  \begin{flushright}
    
    Date Submitted:\makebox[1.5in]{\hrulefill}

    \vspace{12pt}
    
    Advisor:\makebox[1.5in]{\hrulefill}
  \end{flushright}

  \newpage
  
  \pagenumbering{roman}

  \tableofcontents

  \newpage

  \addcontentsline{toc}{section}{Abstract}
  \begin{abstract}
    We propose to design a game engine which will provide the framework for fast, simple deployment of games. We analyzed several different game engine designs to allow programmers to work on game design rather than programming the structure of windows, graphics, sounds, et cetera, but allow them to program a wide range of 2D games. The programmer will handle the logic of each interaction on his own, but trivial functions such as drawing, collision detection, and input will be handled by this engine. The engine is available as a static library programmed in C++, which gives the user the power to program in any language that can implement such a library. A major feature of this engine is pluggable functions which can be implemented by the user, such as artificial intelligence.
  \end{abstract}
  
  \newpage
  
  \pagenumbering{arabic}

  \section{Introduction}
    Game engines can be difficult to learn for a programmer who has just downloaded the libraries or source code for it. The main issues we see are that the programmer is expected to do a lot of work to get started: rudimentary operations like window creation and input detection can be hard to wrap one's mind around. Our goal is to look from a novice's point of view, with an engine which will hand-hold them through these operations until they feel able to extend my own engine's classes. We have no delusions of grandeur: If a programmer sufficiently experienced in game programming sees a need that we do not fulfill, he is free to overload it with his own code.

    We also feel that the basic logic of the program is the responsibility of whoever is programming the game. Our engine provides functions which are necessary to most games, namely collision detection, but the implementer of the engine is responsible for what happens between the objects our engine provides.

  \section{Game Engine}
    TODO: Write how to use

  \section{Design and Implementation}
    ChangeEngine will fulfill the following software requirements:

\begin{enumerate}
  \item General Requirements

  \begin{enumerate}
    \item Single library implementing all functions for a rudimentary game

    \begin{enumerate}
      \item Engine Class
      \item Level Container
      \item Game Object Container
      \item Input Listener
      \item Collision Listener
    \end{enumerate}

    \item Extensible classes for programmers to ``plug in'' their own logic

    \begin{enumerate}
      \item Artificial Intelligence
      \item Input Handler
      \item Collision Handler
    \end{enumerate}

  \end{enumerate}

  \begin{enumerate}
    \item SDL Usage
    \item Collision Detection
    \item Artificial Intelligence
  \end{enumerate}

\end{enumerate}



  \section{Tools and Teamwork}
    This project will primarily be programmed by Cedric Wienold using various programming environments supporting C++ code. Teamwork will be limited to interviews with industry professionals concerning algorithms and class organization advice.

  \section{Analysis}
    Research will be conducted on the following areas, and methods and results will be included in the appenix.

  \section{Related Work}

  \section{Conclusions}

  \section{Future Improvements}
    This project will remain open source for any programmer to extend and improve upon it. ChangeEngine will maintain a pluggable interface in many ways so that programmers need only design their own functions and pass them into the engine if they wish to use them. Artificial intelligence, collision detection, and input detection are all areas which programmers can design their own plug-ins for.

  \newpage

  \appendix
  \section{Research}

  \subsection{Collision Detection}
    In an interview with Cal Poly Alumni Computer Science alumni Daniel Nutting, methods of collision detection employing best possible complexity in average cases were outlined, with worst possible complexity in edge cases being sacraficed. This method will be called the ``Grid Collision Detection'' method.

    \subsubsection{Grid Collision Detection}
      \emph{Theory: } Truly basic collision detection entails each object checking against all other objects for collision, and doing the same for every object. This leads to an average $O(n^2)$.

      The most apparent problem is repeated checks. One solution can be a stack method. For each object, push onto stack. Check collision with everything behind it. INCLUDE PSEUDOCODE HERE.

      The next issue is restricting the number of objects to check on. If objects are not close to each other, there is no point in checking. This is where the grid comes in. For a set of objects, calculate the average X and Y coordinates, and split the field there into 4 quadrants. Do this more as is necessary for the number of objects. INCLUDE PSEUDOCODE HERE.

  \section{Source Code}
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla ac felis nibh. Maecenas vel risus erat, non convallis risus. Vivamus congue suscipit porta. Fusce cursus lobortis metus et rhoncus. Nulla in ligula eget felis vestibulum iaculis. Nullam ac enim at lorem iaculis accumsan. Nullam at diam a turpis blandit tincidunt ut vitae ipsum. Integer quis enim eget est porta rhoncus. Vivamus commodo, lacus nec laoreet pretium, nunc lectus tincidunt mauris, blandit lobortis erat ligula pretium quam. Mauris et libero nec felis tempor aliquam. Maecenas lacus ante, fringilla eget convallis et, fringilla a dui. Nam bibendum, elit porttitor blandit imperdiet, est magna fringilla diam, eu accumsan ante nisl at metus. Cras non gravida quam. Nulla nec lorem lorem. Proin et massa mauris. Aenean non metus orci. Maecenas porta purus et ligula consequat tempus.

\end{document}
